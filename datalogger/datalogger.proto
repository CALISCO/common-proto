syntax = "proto2";

import 'google/protobuf/timestamp.proto';
import 'google/protobuf/empty.proto';
import 'nanopb.proto';

// Helper messages
message StatisticalAggregate {
  optional uint32 samples = 1;
  optional uint32 min = 2;
  optional uint32 max = 3;
  optional uint32 avg = 4;
  optional uint32 stdev = 5;
}

// Actual messages
message DataloggerRecord {
  optional uint32 timestamp_ms = 1;
  optional uint32 timestamp_variability = 2;
  optional uint32 sourceId = 3;
  optional DataloggerPayload payload = 4;
}

message DataloggerPayload {
  oneof value {
    DataloggerHeader header = 1;
    CanMessage receivedCanMessage = 2;
    CanMessage transmittedCanMessage = 3;
    CanErrorCounter canError = 4;
    StatisticalAggregate voltageReading = 5;
    google.protobuf.Empty timingPulse = 6;
    google.protobuf.Timestamp rtcTime = 7;
  }
}

message DataloggerHeader {
  message CanHeader {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).max_size = 32];
  }
  repeated CanHeader canData = 1 [(nanopb).max_count = 2];

  message VoltageHeader {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).max_size = 32];
  }
  repeated VoltageHeader voltageData = 2 [(nanopb).max_count = 8];

  message TimingHeader {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).max_size = 32];
  }
  repeated TimingHeader timingData = 3 [(nanopb).max_count = 2];
}

message CanMessage {
  optional uint32 id = 1;
  enum FrameType {
    STANDARD_FRAME = 0;
    EXTENDED_FRAME = 1;
  }
  optional FrameType length = 2;
  enum RtrType {
    DATA_FRAME = 0;
    REMOTE_FRAME = 1;
  }
  optional RtrType rtr = 3;
  optional bytes data = 4 [(nanopb).max_size = 8];
}

message CanErrorCounter {
  enum ErrorCounterSource {
    TRANSMIT_COUNTER = 0;
    RECEIVE_COUNTER = 1;
  }
  optional ErrorCounterSource source = 3;
  optional uint32 count = 2;
}
