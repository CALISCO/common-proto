syntax = "proto2";

import 'google/protobuf/timestamp.proto';
import 'google/protobuf/empty.proto';
import 'nanopb.proto';

// Helper messages
message StatisticalAggregate {
  optional uint32 samples = 1;
  optional uint32 min = 2;
  optional uint32 max = 3;
  optional uint32 avg = 4;
  optional uint32 stdev = 5;
}

// Actual messages
message DataloggerRecord {
  optional uint32 timestamp_ms = 1;
  optional uint32 timestamp_variability = 2;
  optional uint32 sourceId = 3;
  optional DataloggerPayload payload = 4;
}

message DataloggerPayload {
  oneof value {
    DataloggerHeader header = 1;
    DataloggerSystemInfo system = 2;
    InfoString info = 3;
    CanMessage receivedCanMessage = 4;
    CanMessage transmittedCanMessage = 5;
    CanError canError = 6;
    CanErrorCounter canErrorCount = 7;
    StatisticalAggregate voltageReading = 8;
    google.protobuf.Empty timingPulse = 9;
    google.protobuf.Timestamp rtcTime = 10;
  }
}

message DataloggerHeader {
  optional string name = 1 [(nanopb).max_size = 16];
  optional string ver = 2 [(nanopb).max_size = 64];

  message CanHeader {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).max_size = 8];
  }
  repeated CanHeader canData = 3 [(nanopb).max_count = 2];

  message VoltageHeader {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).max_size = 8];
  }
  repeated VoltageHeader voltageData = 4 [(nanopb).max_count = 4];

  message TimingHeader {
    optional uint32 id = 1;
    optional string name = 2 [(nanopb).max_size = 8];
  }
  repeated TimingHeader timingData = 5 [(nanopb).max_count = 2];
}

message DataloggerSystemInfo {
  optional string info = 1 [(nanopb).max_size = 128];
}

message InfoString {
  optional string info = 1 [(nanopb).max_size = 128];
}

message CanMessage {
  optional uint32 id = 1;
  enum FrameType {
    STANDARD_FRAME = 0;
    EXTENDED_FRAME = 1;
  }
  optional FrameType length = 2;
  enum RtrType {
    DATA_FRAME = 0;
    REMOTE_FRAME = 1;
  }
  optional RtrType rtr = 3;
  optional bytes data = 4 [(nanopb).max_size = 8];
}

message CanError {
  enum ErrorSource {
    ERROR_WARNING = 0;
    ERROR_PASSIVE = 1;
    BUS_OFF = 2;
    DATA_OVERRUN = 4;
    ARBITRATION_LOST = 5;
    UNKNOWN = 126;
    OTHER = 127;
  }
  optional ErrorSource source = 1;
}

message CanErrorCounter {
  enum ErrorCounterSource {
    TRANSMIT_COUNTER = 0;
    RECEIVE_COUNTER = 1;
  }
  optional ErrorCounterSource source = 1;
  optional uint32 count = 2;
}
