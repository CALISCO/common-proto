syntax = "proto2";

import 'google/protobuf/timestamp.proto';
import 'nanopb.proto';

// Helper messages
message StatisticalAggregate {
  optional uint32 samples = 1;
  optional int32 min = 2;
  optional int32 max = 3;
  optional int32 avg = 4;
  optional uint32 stdev = 5;
}

// Actual messages
message DataloggerRecord {
  optional uint32 timestamp_ms = 1;
  optional uint32 timestamp_variability = 2;
  optional uint32 sourceId = 3;
  optional DataloggerPayload payload = 4;
}

message DataloggerPayload {
  oneof value {
    SourceDef sourceDef = 1;
    InfoString info = 2;
    CanMessage receivedCanMessage = 3;
    CanMessage transmittedCanMessage = 4;
    CanError canError = 5;
    CanErrorCounter canErrorCount = 6;
    StatisticalAggregate voltageReading = 7;
    StatisticalAggregate temperatureReading = 8;
    StatisticalAggregate loopTimer = 9;
    google.protobuf.Timestamp rtcTime = 10;
  }
}

message SourceDef {
  enum SourceType {
    UNKNOWN = 0;
    CAN = 1;
    TIME = 2;
    VOLTAGE = 3;
    TEMPERATURE = 4;
  }
  optional SourceType sourceType = 1;
  optional string name = 2 [(nanopb).max_size = 32];
}

message InfoString {
  optional string info = 1 [(nanopb).max_size = 128];
}

message CanMessage {
  optional uint32 id = 1;
  enum FrameType {
    STANDARD_FRAME = 0;
    EXTENDED_FRAME = 1;
  }
  optional FrameType length = 2;
  enum RtrType {
    DATA_FRAME = 0;
    REMOTE_FRAME = 1;
  }
  optional RtrType rtr = 3;
  optional bytes data = 4 [(nanopb).max_size = 8];
}

message CanError {
  enum ErrorSource {
    UNKNOWN = 0;
    ERROR_WARNING = 1;
    ERROR_PASSIVE = 2;
    BUS_OFF = 3;
    DATA_OVERRUN = 4;
    ARBITRATION_LOST = 5;
    OTHER = 127;
  }
  optional ErrorSource source = 1;
}

message CanErrorCounter {
  enum ErrorCounterSource {
    TRANSMIT_COUNTER = 0;
    RECEIVE_COUNTER = 1;
  }
  optional ErrorCounterSource source = 1;
  optional uint32 count = 2;
}
